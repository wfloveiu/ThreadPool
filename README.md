# C++11实现线程池

[C++11参考博客](https://www.cnblogs.com/lzpong/p/6397997.html)

[C参考视频]([线程池工作原理和实现 - 【C语言版 】C/C++_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jV411J795/?spm_id_from=333.337.search-card.all.click&vd_source=4d8f38d509aec992e4fd21510d06c9cd))

一句话说明线程池：**管理一个任务队列，一个线程vector或数组，让这些线程去执行一个统一的任务调度函数，在这个调度函数内部循环地从任务队列中获取一个task，并执行**

需要的数据结构：

- 任务队列queue，使用queue实现
- 线程池pool，使用vector存放创建出来的线程id
- 这是一个典型的生产者和消费者模型。生产者是commit，消费者是worker，临界资源就是任务队列。因此，需要一个mutex锁来锁共享资源；
- 一般的生产者和消费者需要2个条件变量，一个是not_empty，当缓冲区为空时阻塞消费者取任务；另一个是not_full，当缓冲区满时阻塞生产者生产任务。但本示例中使用queue，并未考虑队列长度（即默认队列中可以无限放任务）。不过**最好还是要加上对任务队列中任务数目的限制**
- 管理者线程，在C++11项目中未提供管理者线程，而是使用`\#define THREADPOOL_AUTO_GROW`来做出一些对线程的管理；在C项目中实现了管理者线程。管理者线程的作用有两个：当线程空闲的数量较多时，可以销毁部分空闲线程；当线程不够时，可以主动地去生产线程以满足任务需求

下面是部分代码对应地知识点记录和学习

## 原子类型(std::atomic)

```c++
atomic<bool> _run{true};   // 线程池是否运行
atomic<int> _idlThrNum{0}; // 空闲的线程数量
```

我们平时编程时很多情况下需要在多个线程间共享一个简单的类型变量(int，bool，pointer等)，对这种简单临界资源的访问，如有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。**即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱**（因为一条语句可能会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）。正常情况下，我们想到就是使用std::mutex来解决上述对临界资源访问的问题，**使用std::mutex程序执行不会导致混乱，但是每一次循环都要加锁解锁是的程序开销很大**。 为了提高性能，C++11提供了原子类型(`std::atomic<T>`)，它提供了多线程间的原子操作，**可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。它定义在`<atomic>`头文件中**，原子类型是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。从效率上来说，原子操作要比互斥量的方式效率要高。互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。 原子操作，一般都是指“不可分割的操作”；是一系列不可被 CPU 上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰。 由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了 CAS 循环，当大量的冲突发生时，该等待还是得等待！但是总归比锁要好。
链接：https://juejin.cn/post/7086226046931959838

## lambda匿名函数

```c++
 workers.emplace_back([this]{this->DoTask(); });
// this 是引用域外的变量 this指针
```

使用构造函数进行线程的初始化，执行函数是拉姆达匿名函数（其实是在lambda函数中，执行了这个类的一个成员函数DoTask）。关于C++初始化线程的方法，参考：[始化线程的所有方法以及多线程传参的方式比较](https://blog.csdn.net/weixin_43297891/article/details/131266233)

## commit函数


